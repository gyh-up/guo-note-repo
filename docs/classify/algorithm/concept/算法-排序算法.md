---
typora-root-url: ..\..\..\public
---

## 冒泡排序

一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为元素会经由交换慢慢“浮”到数列的顶端。

1、比较相邻的元素。如果第一个比第二个大，交换它们两个；

2、对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；

3、针对所有的元素重复以上的步骤，**除了最后 一个**；

4、重复步骤1~3，直到排序完成

## 选择排序

选择排序的思想其实和冒泡排序有点类似，选择排序可以可以看成冒泡排序的优化。

- 首先，找到数组中最大（最小）的那个元素；
- 其次，将它和数组的第一个元素交换位置（如果第一个元素就是最大/小元素，那么它就和自己交换）
- 再次，在剩下的元素中找到最大/小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。

这个方法叫做选择排序，因为它在不断地选择剩余元素之中的最大/小值。

## 插入排序

- 对于未排序数据，在已排序序列中从后往前扫描，找到相应位置并插入（一般从第二个元素开始排序）
- 为了给要插入的元素腾出空间，我们需要将插入位置之后的已排序元素再都向右移动一位。

插入排序所需的时间取决于输入中元素的初始顺序。例如，对于一个很大且其中的元素已经有序（或接近有序)的数组进行排序将会比对随机排序的数组或者是逆序数组进行排序要快得多。

总的来说，**插入排序对于部分有序的数组十分高效（如希尔排序的增量分组）**，也很适合小规模数组。**插入排序也是一些高级排序算法的中间过程。**

## 希尔排序

- **一种基于插入排序的快速的排序算法。**简单插入排序对于大规模乱序数组很慢，因为元素只能一点一点地从数组的一端移动到另一端。
- 希尔排序为了加快速度简单地改进了插入排序，也称为缩小增量排序，同时该算法是冲破 O(n^2) 的第一批算法之一。
- 希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；然后缩小增量继续分组排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1时，整个文件恰被分成一组，再次排序，完成整个数组的排序。这个不断缩小的增量，就构成了一个增量序列。

#### 希尔排序中的增量序列

从理论上说，只要一个数组是递减的，并且最后一个值是 1，都可以作为增量序列使用。有没有一个步长序列，使得排序过程中所需的比较和移动次数相对较少，并且无论待排序列记录数有多少，算法的时间复杂度都能渐进最佳呢？但是从数学上来说，无法证明某个序列是“最好的”。

常用的增量序列

- 希尔增量序列：{N/2 , (N/2)/2 , ..... , 1}，其中 N 为原始数组的长度，这是最常用的序列，但却不是最好的
- Hibbard 序列：{2^k - 1，... , 3 , 1}
- Sedgewick 序列：{.... , 109 , 41 , 19 , 5 , 1} 表达式为 `9\*4^i - 9\*2^i + 1` 或者 `4^i - 3*2^i + 1`

## 快速排序

- 快速排序（Quciksort）是对冒泡排序的一种改进，也是采用分治法的一个典型的应用。
- 首先任意选取一个数据（比如数组的第一个数）作为关键数组，我们成为基准数，然后将所有比它小的数放到塔前面，所以比他大的数都放到他后面，这个过程成为一趟快速排序，也称为分区（partition）操作。
- 通过一趟快速排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据都要小，然后再按照此方法对这两部分数据分别进行快速排序，整个快速排序可以递归进行，以此达到整个数据变成有序序列。

快速排序有导致空间消耗，可以引入分区指示器来优化。

参考视频：[十大排序算法之快速排序](https://www.bilibili.com/video/BV1eg411w7gn?p=35&spm_id_from=pageDriver&vd_source=2365b1baf9eff4a0af3aabdb705341bd)

#### 快速排序中的基准数

- 基准的选取：最优的情况是基准值刚好取在无序区的中间，这样能够最大效率地让两边排序，同时最大地减少递归划分的次数，但是一般很难做到最优。基准的选取一般有三种方式，选取数组的第一个元素，选取数组的最后一个元素，以及第一个，最后一个以及中间的元素的中位数（如4 5 6 7，第一个 4，最后一个 7，中间的为 5，这三个数的中位数为 5，所以选择 5 作为基准）
- Dual-Pivot 快排（双轴快排）：两个基准数的快速排序算法，其实就是用两个基准数，把整个数组分成三份来进行快速排序，在这种新的算法下面，比经典快速排序从实验来看节省了 10% 的时间。

***为了提升性能，有时我们在分割后独立的两部分的个数小于某个数（比如 15）的情况下，会采用其他排序算法，比如插入排序。***

## 归并排序

对于给定的一组数据，利用递归与分治技术将数据序列划分成为越来越小的半字表，在对半子表排序后，再用递归方法将排好序的半子表合并成为越来越大的有序序列。

|   原始数组    |                    | 35 63 48 9 86 24 53 72 |                      |
| :-----------: | :----------------: | :--------------------: | :------------------: |
|    1、拆分    |     35 63 48 9     |                        |     86 24 53 72      |
|  2、继续拆分  | 35 63         48 9 |                        | 86 24          53 72 |
| 3、孙子表排序 | 63 35         48 9 |                        | 86 24          72 53 |
| 4、合并孙子表 |     63 48 35 9     |                        |     86 72 53 24      |
|  5、再次合并  |                    | 86 72 63 53 48 35 24 9 |                      |

步骤一：拆分

步骤二：继续拆分

步骤三：子表第一个元素开始比较，较大值取出入队。如63 与 48 比较，63入队；35 与 48 比较 ，48入队

步骤四：同步骤三

- 为了提升性能，有时我们在半子表的个数小于某个数（比如 15）的情况下，对半子表的排序采用其他艾许算法，比如插入排序
- 若将两个有序表合成一个有序表，成为 2-路归并，与之对应的还有多路归并

## *堆排序

- 许多应用程序都需要处理有序的元素，但不一定要求它们全部有序，或者不一定要一次就将它们排序，很多时候，我们每次只需要操作数据中的最大元素（最小元素），那么有一种基于二叉堆的数据结构可以提供支持。
- 所谓的二叉堆，是一个完全二叉树的结构，同时满足堆的性质：即子结点的键值和索引总是小于（或者大于）它的父节点。在一个二叉堆中，根节点总是最大（或者最小）节点，这样堆我们称之为最大（小）堆。
- 堆排序算法就是抓住了这一特点，每次都取堆顶的元素，然后将剩余的元素重新调整为最大（最小）堆，以此类推，最终得到排序的序列。



## 计数排序、桶排序、基数排序

### 计数排序

计数排序、基数排序、桶排序三种排序算法都利用了桶的概念，但对桶的使用方法上有差异

- 计数排序是一个排序时不比较元素大小的排序算法

- 计数排序对一定范围内的整数排序时候的速度非常快，一般快于其他排序算法。但计数排序局限性比较大，只限于对整数进行排序，而且待排序元素值分布较连续，跨度小的情况。

- 如果一个数组里所有元素都是整数，而且都在 0-k 以内。那对于数组里每个元素来说，如果能知道数组里有多少项小于或等于该元素，就能准确地给出该元素在排序后的数组的位置上。


```
原始数组 2 5 3 0 2 3 0 3

对于这个数组来说，元素 5 之前有 8 个元素小于等于 5（含 5 本身），因此排序后 5 所在的位置肯定是 7，只要构造一个（5+1）大小的数组，里面存下所有对应 A 中每个元素之前的元素个数，就能在线性时间内完成排序。

初始化一个大小为（5+1）的计数数组（所有元素初始化值为 0），遍历整个原始数组，将原始数组中每个元素值转化为计数数组下标，并将计数数组下标对应的元素值大小+1

计数数组 	 2 0 2 3 0 1
计数数组下标	0 1 2 3 4 5

计数数组下标即为原始数组对应的值，计数数组的值对应原始数组中计数数组下标值的个数
```

- 实际应用中我们会同时找出数组中的 max 和 min，主要为了尽量节省空间。试想 [1003,1001,1030,1050]这样的数据要排序，真的需要建立长度为 1050+1 的数组吗？我们只需要长度为 1050-1003+1=48 的数组（先不考虑额外 +1 的长度），就能囊括从最小到最大元素之间的所有元素了。
- 如果待排序数组的元素值跨度很大，比如[99999,1,2]，为三个元素排序要使用 99999-1+1 的空间，是在是浪费。所以计数排序适用于待排序元素值分布较连续、跨度小的情况。

### 桶排序

计数排序、基数排序、桶排序三种排序算法都利用了桶的概念，但对桶的使用方法上有差异

- 桶排序是计数排数的升级版
- 桶排序（Bucket sort）的工作原理：加入输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序）

```
原始数组 35 23 48 9 16 24 5 11 32 17
我们可以建立5个桶，每个桶按范围顺序依次是[0,10)、[10,20).....[40,50)，注意是左闭右开区间。
对待排序数组，5和9会被放到[0,10)这个桶中，.......，48会被放到[40,50)这个桶中，对这5个桶的元素分别排序。
依次取出5个桶中元素，得到排序后的序列。
```

**在桶排序中保证元素均匀分布到各个桶尤为关键**。

举个反例，有数组[0,9,4,5,8,7,6,3,2,1]要排序，它们都是10以下的数，如果还按照上面的范围[0,10)建立桶，全部的元素将进入同一个桶中，此时桶排序就失去了意义。实际情况我们很可能事先就不知道输入数据是什么，为了保证元素均匀分布到各个桶中，需要建立多少个桶，每个桶的范围是多少呢？

桶排序利用函数的映射关系，减少了几乎所有的比较工作中。实际中，桶排序的 f(k) 值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块（桶），然后只需要对桶中的少量数据做先进的比较排序即可。

### 基数排序

计数排序、基数排序、桶排序三种排序算法都利用了桶的概念，但对桶的使用方法上有差异

- 常见的数据元素一般是由若干位组成的，比如字符串由若干字符组成，整数由若干位0~9数字组成。基数排序按照从右往左的顺序，依次将每一位都当做一次关键字，然后按照该关键字对数组的元素入桶，每一轮入桶都基于上一轮入桶的结果；完成所有位的入桶后，整个数组就达到有序状态。
- 比如对于数字2985，从右往左就是先以个位为关键字进行入桶，然后是十位、百位、千位，总共需要四轮。基数排序也是一种无需比较的排序算法。 

![image-20221125154047817](/algorithm_concept/基数排序示例.png)

基数是什么意思？对于一个十进制整数，每一位都只可能是0~9中的某一个，总共10种可能。那10就是它的基数，同理二进制数字的基为2；对于字符串，如果它使用的是8位的扩展ASCII字符集，那么它的基就是256。

### 基数排序 vs 计数排序 vs 桶排序

这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：

基数排序：根据键值的每位数字来分配桶

计数排序：每个桶只存储单一键值

桶排序：每个桶储存一定范围的数值

## 总结

![image-20221125155718876](/algorithm_concept/排序算法比较总结.png) 