# redis内存淘汰策略

`Redis` 的数据已经设置了TTL，不是过期就已经删除了吗？为什么还存在所谓的淘汰策略呢？这个原因我们需要从 `redis` 的过期策略聊起。

## redis的过期策略

### 定期删除

**`redis` 会将每个设置了过期时间的 `key` 放入一个独立的字典中，以后会定期遍历这个字典来删除到期的 `key`。**

`redis` 默认**会每秒进行十次过期扫描**，过期扫描不会遍历过期字典中所有的 `key`，而是采用了一种简单的**贪心策略**。

1、从过期字典中随机20个 `key`；

2、删除这20个 `key` 中已经过期的 `key`；

3、如果过期的 `key` 比例**超过四分之一**，那就重复步骤1；

`redis` 默认是每隔 `100ms` 就**随机抽取**一些设置了过期时间的 `key`，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？假如 `redis` 存了几十万个 `key` ，每隔 `100ms` 就遍历所有的设置过期时间的 `key` 的话，就会给 `CPU` 带来很大的负载。

### 惰性删除

**所谓的惰性删除就是在客户端访问这个 `key` 的时候，`redis` 对 `key` 的过期时间进行检查，如果过期了就立即删除，不会返回任何东西。**

定期删除可能会导致很多过期的 `key` 到了过期时间没有被及时删除，所有就有了惰性删除。假如过期 `key`，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 `key`，才会被 `redis` 给删除掉。这就是所谓的惰性删除，即当你主动去查过期的 `key` 时，如果发现 `key` 过期了，就立即进行删除，不返回任何东西.

**总结：定期删除是集中处理，惰性删除是零散处理。**

## 内存淘汰策略

有了以上过期策略的说明后，就很容易理解为什么需要淘汰策略了，因为不管是定期采样删除还是惰性删除都不是一种完全精准的删除，还是会存在 `key` 过期了没有被删除掉的场景 ，所以就需要内存淘汰策略进行补充。

### 全局的键空间选择性移除

`noeviction`：当内存使用超过配置的时候会返回错误，不会驱逐任何键

`allkeys-lru`：加入键的时候，如果过限，首先通过 `LRU` 算法驱逐最久没有使用的键

`allkeys-lfu`：从所有键中驱逐使用频率最少的键

`allkeys-random`：加入键的时候如果过限，从所有key随机删除

### 设置过期时间的键空间选择性移除

`volatile-ttl`：从配置了过期时间的键中驱逐马上就要过期的键

`volatile-lru`：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键

 `volatile-lfu`：从所有配置了过期时间的键中驱逐使用频率最少的键

`volatile-random`：加入键的时候如果过限，从过期键的集合中随机驱逐