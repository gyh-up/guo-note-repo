---
typora-root-url: ..\..\public
---

# redis的缓存击穿、缓存穿透、缓存雪崩

## 缓存穿透

### 概念

缓存和数据库中都没有的数据，可用户还是源源不断的发起请求，导致每次请求都会到数据库，从而压垮数据库。

比如客户查询一个根本不存在的东西，首先从 `Redis` 中查不到，然后会去数据库中查询，数据库中也查询不到，那么就不会将数据放入到缓存中，后面如果还有类似源源不断的请求，最后都会压到数据库来处理，从而给数据库造成巨大的压力。

![](/redis/redis-缓存穿透.png)

### 解决方案

#### 方案一、业务层校验

用户发过来的请求，根据请求参数进行校验，对于明显错误的参数，直接拦截返回。

比如，请求参数为主键自增 `id`，那么对于请求小于 `0` 的 `id` 参数，明显不符合，可以直接返回错误请求。

#### 方案二、不存在数据设置短过期时间

对于某个查询为空的数据，可以将这个空结果进行 `Redis` 缓存，但是设置很短的过期时间，比如 `30s`，可以根据实际业务设定。注意一定不要影响正常业务。

#### 方案三、布隆过滤器

关于布隆过滤器，后面会详细介绍。布隆过滤器是一种数据结构，利用极小的内存，可以判断大量的数据**一定不存在或者可能存在**。

对于缓存穿透，我们可以将查询的数据条件都哈希到一个足够大的布隆过滤器中，用户发送的请求会先被布隆过滤器拦截，一定不存在的数据就直接拦截返回了，从而避免下一步对数据库的压力。

#### 方案四、用户黑名单限制

当发生异常情况时，实时监控访问的对象和数据，分析用户行为，针对故意请求、爬虫或攻击者，进行特定用户的限制；

### 扩展：布隆过滤器的实现

作为一个过滤器需要满足什么条件？

- 速度得快，得从内存查，如果从硬盘查的话还不如直接查数据库
- 因为过滤器里面得存入数据库所有的数据，所以内存势必是比较紧张的，所以内存要做到绝对的节省，说到节省内存，大家应该很容易能想到 `redis` 里面的 `setbit` 操作

#### 布隆过滤器的实现

写入过程

- 通过 `bit` 数组来标识数据
- 比如 `id=10` 的数据，通过 `hash` 算法算出来结果为 `1`
- 把 `bit` 数组下表为 `1` 的位置的值标记为 `1`

查询过程

- 将 `id=10` 做 `hash` 运算，得到结果 `1`
- 看 `bit` 数组下标为 `1` 的数据标识为 `1`，则说明数据存在

**其实我们看上面的算法是存在一定的问题的**

1. 只要是 `hash` 运算，就会存在 `hash` 碰撞问题，比如 `id=10` 和 `id=100` 可能经过 `hash` 运算之后结果都为 `1`，那么 `id=10` 写入之后查询 `id=100` 是否存在会误判为 `id=100` 也存在 
2. 当 `bit` 数组满了之后，查询的错误率肯定是百分之百，因为每个数据都存在

这些其实都是导致错误率的原因，错误率是不可能避免的，但是咱们可以减少错误率，**减少错误率的方法有两个：**

1. 加大 `bit` 数组的长度，对于 `bit` 数组的长度的增加是不用担心的，因为是 `bit` 操作，所以可以加到很大的值
2. 增加 `hash` 函数的个数，`hash` 函数的个数增加了，说明标识一个数组需要的位置就会变多。这样会降低发生 `hash` 碰撞的概率。但是 `hash` 的函数也不是越多越好，需要参照数组的长度来定

**`hash` 错误率：**

**布隆算法说数据存在，那么实际有可能不存在**

**如果数据不存在。那么一定不存在**

#### 布隆过滤器的使用

1、下载 `redisbloom` 插件（`redis` 官网下载即可）

```
wget https://github.com/RedisLabsModules/rebloom/archive/v1.1.1.tar.gz
```

2、解压并安装，生成 `.so` 文件

```
[root@redis]# tar -zxvf v1.1.1.tar.gz
[root@redis]# cd Redisbloom-1.1.1/
[root@redisbloom-1.1.1]# make
[root@redisbloom-1.1.1]# ls
contrib  Dockerfile  docs  LICENSE  Makefile  mkdocs.yml  ramp.yml  README.md  rebloom.so  src  test
```

3、在 `redis` 配置文件 `redis.conf` 中加入该模块即可

```bash
[root@redis]# vim redis.conf
#####################MODULES#################                                                      # Load modules at startup. If the server is not able to load modules
# it will abort. It is possible to use multiple loadmodule directives.
loadmodule /usr/local/redis/redisbloom-1.1.1/rebloom.so
```

4、重新启动 `redis`

```php
redis-server ./redis.conf
```

5、测试安装是否成功

```bash
127.0.0.1:6379> bf.add users user2  //写入数据user2
(integer) 1
127.0.0.1:6379> bf.add users user1  //写入数据user1
(integer) 1
127.0.0.1:6379> bf.exists users user1  //查询user1存在
(integer) 1
127.0.0.1:6379> bf.exists users user3   //查询user3不存在
(integer) 0
```

上面说过布隆过滤器存在误判的情况，在 `redis` 中有两个值决定布隆过滤器的准确率：

- `error_rate` ：允许布隆过滤器的错误率，这个值越低过滤器的位数组的大小越大，占用空间也就越大。
- `initial_size` ：布隆过滤器可以储存的元素个数，当实际存储的元素个数超过这个值之后，过滤器的准确率会下降。`redis` 中有一个命令可以来设置这两个值：

```
bf.reserve users 0.01 100
```

三个参数的含义：

第一个值是过滤器的名字。

第二个值为 `error_rate` 的值。

第三个值为 `initial_size` 的值。

## 缓存击穿

### 概念

`Redis` 中一个热点 `key` 在失效的同时，大量的请求过来，从而会全部到达数据库，压垮数据库。

这里要注意的是这是某一个热点 `key` 过期失效，和后面介绍缓存雪崩（大量的 `key` 值）是有区别的。比如淘宝双十一，对于某个特价热门的商品信息，缓存在 `Redis` 中，刚好 `0` 点，这个商品信息在 `Redis` 中过期查不到了，这时候大量的用户又同时正好访问这个商品，就会造成大量的请求同时到达数据库。

![img](/redis/redis-缓存击穿.png)

### 解决方案

#### 方案一、设置热点数据永不过期

对于某个需要频繁获取的信息，缓存在 `Redis` 中，并设置其永不过期。当然这种方式比较粗暴，对于某些业务场景是不适合的。

#### 方案二、定时更新

比如这个热点数据的过期时间是 `1h`，那么每到 `59minutes` 时，通过定时任务去更新这个热点 `key`，并重新设置其过期时间。

#### 方案三、互斥锁

**这是解决缓存击穿比较常用的方法。**

互斥锁简单来说就是在 `Redis` 中根据key获得的 `value` 值为空时，先锁上，然后从数据库加载，加载完毕，释放锁。若其他线程也在请求该 `key` 时，发现获取锁失败，则睡眠一段时间（比如 `100ms`）后重试。

```
public String get(key) {
    String value = redis.get(key);
    if (value == null) { //代表缓存值过期
        //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
        if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置成功
            value = db.get(key);
            redis.set(key, value, expire_secs);
            redis.del(key_mutex);
        } else {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
            sleep(50);
            get(key);  //重试
        }
    } else {
    	return value;      
    }
}
```

#### 方案四、”提前“使用互斥锁

在 `value` 内部设置一个比缓存（`Redis`）过期时间短的过期时间标识，当异步线程发现该值快过期时，马上延长内置的这个时间，并重新从数据库加载数据，设置到缓存中去。

## 缓存雪崩

### 概念

`Redis` 中缓存的数据大面积同时失效，或者 `Redis` 宕机，从而会导致大量请求直接到数据库，压垮数据库。

对于一个业务系统，**如果 `Redis` 宕机或大面积的 `key` 同时过期**，会导致大量请求同时打到数据库，这是灾难性的问题。

![img](/redis/redis-缓存雪崩.png)

### 解决方案

#### 方案一、设置有效期均匀分布

避免缓存设置相近的有效期，我们可以在设置有效期时增加随机值；或者统一规划有效期，使得过期时间均匀分布。

#### 方案二、数据预热

对于即将来临的大量请求，我们可以提前走一遍系统，将数据提前缓存在 `Redis` 中，并设置不同的过期时间。

#### 方案三、保证 `Redis` 服务高可用

`Redis` 的哨兵模式和集群模式，为防止 `Redis` 集群单节点故障，可以通过这两种模式实现高可用。

#### 方案四、热点数据不失效

热点数据可以考虑不失效，后台异步更新缓存，适用于不严格要求缓存一致性的场景。