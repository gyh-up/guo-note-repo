---
typora-root-url: ..\..\public
---

# redis 数据类型简介

该内容比较基础，大佬可以略过 

## `string` 类型

`string` 类型是 `redis` 的最基础的数据结构，也是最经常使用到的类型。**而且其他的四种类型多多少少都是在字符串类型的基础上构建的，所以 `string` 类型是 `redis` 的基础**。 

**string 类型的值最大能存储 `512MB`**，这里的 `string` 类型可以是简单字符串、复杂的 `xml/json` 的字符串、二进制图像或者音频的字符串、以及可以是数字的字符串。 

### 常用命令

| **命令** | **描述**                                                     | **用法**                                                |
| -------- | :----------------------------------------------------------- | ------------------------------------------------------- |
| `SET`    | （1）将字符串值 `Value` 关联到Key<br />（2）`Key` 已关联则覆盖，无视类型<br />（3）原本 `Key` 带有生存时间 `TTL`，那么 `TTL` 被清除 | `SET key value [EX seconds] [PX milliseconds] [NX\|XX]` |
| `GET`    | （1）返回 `key` 关联的字符串值<br />（2）`key` 不存在返回 `nil`<br />（3）`key` 存储的不是字符串，返回错误，因为 `GET` 只用于处理字符串 | `GET key`                                               |
| `MSET`   | （1）同时设置一个或多个 `Key-Value` 键值对<br />（2）某个给定 `Key` 已经存在，那么 `MSET` 新值会覆盖旧值<br />（3）如果上面的覆盖不是希望的，那么使用 `MSETNX` 命令，所有 `Key` 都不存在才会进行覆盖<br />（4）**`MSET` 是一个原子性操作**，所有 `Key` 都会在同一时间被设置，不会存在有些更新有些没更新的情况 | `MSET key value [key value ...]`                        |
| `MGET`   | （1）返回一个或多个 `Key` 对应的 `Value`<br />（2）某个 `Key` 不存在那么这个 `Key` 返回 `nil` | `MGET key [key ...]`                                    |
| `SETEX`  | （1）将 `Value` 关联到 `Key`<br />（2）设置 `Key` 生存时间为 `seconds`，单位为秒<br />（3）如果 `Key` 对应的 `Value` 已经存在，则覆盖旧值<br />（4）`SET` 也可以设置失效时间，但是不同在于 `SETNX` 是一个原子操作，即关联值与设置生存时间同一时间完成 | `SETEX key seconds value`                               |
| `SETNX`  | （1）将 `Key` 的值设置为 `Value`，当且仅当 `Key` 不存在<br />（2）若给定的 `Key` 已经存在，`SEXNX` 不做任何动作 | `SETNX key value`                                       |

PS：

　　①上面的 `ttl` 命令是返回 `key` 的剩余过期时间，单位为秒。

　　②`mset` 和 `mget` 这种批量处理命令，能够极大的提高操作效率。因为

```
1次命令耗时 = 1 次网络传输时间 + 1 次命令执行时间
n 个命令耗时 = n 次网络传输时间 + n 次命令执行时间
```

​		而批量处理命令会将 n 次网络时间缩减为 1 次网络时间，也就是

```
n次命令耗时 = 1 次网络传输时间 + n 次命令处理时间
```

　　但是需要注意的是，`Redis` 是单线程的，如果一次批量处理命令过多，会造成 `Redis` 阻塞或网络拥塞（传输数据量大）。

　　③`setnx` 可以用于实现分布式锁，具体实现方式后面会介绍。

### 自增自减

　　上面是 `string` 类型的基本命令，下面介绍几个自增自减操作，这在实际工作中还是特别有用的（分布式环境中统计系统的在线人数，利用 `Redis` 的高性能读写，在 `Redis` 中完成秒杀，而不是直接操作数据库）。

| **命令** | **描述**                                                     | **用法**               |
| -------- | ------------------------------------------------------------ | ---------------------- |
| `INCR`   | （1）`Key` 中存储的数字值 `+1`，返回增加之后的值<br />（2）`Key` 不存在，那么 `Key` 的值被初始化为 `0` 再执行 `INCR`<br />（3）如果值包含错误类型或者字符串不能被表示为数字，那么返回错误<br />（4）值限制在 `64` 位有符号数字表示之内， 即  `-9223372036854775808~9223372036854775807` | `INCR key`             |
| `DECR`   | （1）`Key` 中存储的数字值 `-1`<br />（2）其余同 `INCR`       | `DECR key`             |
| `INCRBY` | （1）将 `key` 所存储的值加上增，返回增加之后的值<br />（2）其余同 `INCR` | `INCRBY key increment` |
| `DECRBY` | （1）将 `key` 所存储的值减去减量，返回减去之后的值<br />（2）其余同 `INCR` | `DECRBY key decrement` |

更多 `string` 命令参考这里：https://www.runoob.com/redis/redis-strings.html

### `string` 数据类型的应用 

- #### `session` 共享 

一个分布式 `web` 服务将用户的 `Session` 信息（比如：登录信息）记录到各自服务器中，这样会出现一个问题，在负载均衡的情况下，服务器会将用户的访问均衡到不同的服务器上，用户刷新一次访问可能就会发现需要重新登录，这个问题对于用户体验来说是无法容忍的。 

为了解决这个问题我们会是使用 `Redis` 将用户的 `Session` 进行集中管理，这样就只需要保证 `Redis` 的高可用以及扩展性，每次用户的登录或者查询登录都从 `Redis` 中获取 `Session` 信息。 

- #### [`setnx` 分布式锁](/classify/redis/redis分布式锁)

`string` 类型的 `setnx` 的作用是 **“当 `key` 不存在时，设值并返回 `1` ，当 `key` 已经存在时，不设值并返回 `0` ”**，“判断 `key` 是否存在” 和 “设值” 两个操作是原子性地执行的，因此可以用 `string` 类型作为分布式锁，返回 `1` 表示获得锁，返回 `0` 表示没有获得锁。

例如，为了保证定时任务的高可用，往往会同时部署多个具备相同定时任务的服务，但是业务上只希望其中的某一台服务执行定时任务，当定时任务的时间点触发时，多个服务同时竞争一个分布式锁，获取到锁的执行定时任务，没获取到的放弃执行定时任务。定时任务执行完时通过 `del` 命令删除 `key` 即释放锁，如果担心 `del` 命令操作失败而导致锁一直未释放，可以通过 `expire` 命令给锁设置一个合理的自动过期时间，确保即使 `del` 命令失败，锁也能被释放。不过 `expire` 命令同样存在失败的可能性，如果你用的是 `Java` 语言，建议使用 `JedisCommands` 接口提供的 `String set(String key， String value， String nxxx， String expx， long time)` 方法，这个方法可以将 `setnx` 和 `expire` 原子性地执行（相信其它语言的 `Redis` 客户端也应当提供了类似的方法）。

- #### 计数器 

​	`decr`  和 `incr`  命令

## `list` 类型

`list` 类型是用来存储多个有序的字符串的，列表当中的每一个字符看做一个元素，一个列表当中可以存储有一个或者多个元素，**`redis` 的 `list` 支持存储 `2^32-1` 个元素**。

`redis` 可以从列表的**两端进行插入 `push` 和 弹出 `pop` 元素，支持读取指定范围的元素集，或者读取指定下标的元素等操作。**`redis` 列表是一种比较灵活的链表数据结构，它可以充当队列或者栈的角色。

`redis` 列表是链表型的数据结构，所以它的元素是有序的，而且列表内的元素是可以重复的。意味着它可以根据链表的下标获取指定的元素和某个范围内的元素集。

### 常用命令 

| **命令**    | **描述**                                                     | **用法**                               |
| ----------- | ------------------------------------------------------------ | -------------------------------------- |
| `LPUSH`     | （1）将一个或多个值 `value`  插入到列表`key` 的表头<br />（2）如果有多个`value` 值，那么各个`value` 值按从左到右的顺序依次插入表头<br />（3）`key` 不存在，一个空列表会被创建并执行 `LPUSH`  操作<br />（4）`key` 存在但不是列表类型，返回错误 | `LPUSH key value [value ...]`          |
| `LPUSHX`    | （1）将值 `value` 插入到列表 `key` 的表头，当且仅当  `key` 存在且为一个列表<br />（2）`key` 不存在时，`LPUSHX`  命令什么都不做 | `LPUSHX key value`                     |
| `LPOP`      | （1）移除并返回列表 `key` 的头元素                           | `LPOP key`                             |
| `LRANGE`    | （1）返回列表 `key`  中指定区间内的元素，区间以偏移量 `start` 和  `stop`  指定<br />（2）可使用负数下标，`-1` 表示列表最后一个元素，`-2` 表示列表倒数第二个元素，以此类推（3）`start` 大于列表最大下标，返回空列表<br />（4）`stop` 大于列表最大下标，`stop`  = 列表最大下标 | `LRANGE key start stop`                |
| `LREM`      | （1）根据`count` 的值，移除列表中与 `value` 相等的元素<br />（2）`count>0` 表示从头到尾搜索，移除与 `value`  相等的元素，数量为 `count`<br />（3）`count<0` 表示从从尾到头搜索，移除与  `value`  相等的元素，数量为 `count`<br />（4）`count=0`  表示移除表中所有与 `value` 相等的元素 | `LREM key count value`                 |
| `LSET`      | （1）将列表 `key` 下标为  `index` 的元素值设为 `value`<br />（2）`index` 参数超出范围，或对一个空列表进行 `LSET` 时，返回错误 | `LSET key index value`                 |
| `LINDEX`    | （1）返回列表 `key` 中，下标为 `index` 的元素                | `LINDEX key index`                     |
| `LINSERT`   | （1）将值 `value` 插入列表 `key` 中，位于 `pivot` 前面或者后面<br />（2）`pivot` 不存在于列表 `key` 时，不执行任何操作<br />（3）`key`  不存在，不执行任何操作 | `LINSERT key BEFORE|AFTER pivot value` |
| `LLEN`      | （1）返回列表  `key`  的长度<br />（2）`key`  不存在，返回 `0` | `LLEN key`                             |
| `LTRIM`     | （1）对一个列表进行修剪，让列表只返回指定区间内的元素，不存在指定区间内的都将被移除 | `LTRIM key start stop`                 |
| `RPOP`      | （1）移除并返回列表 `key` 的尾元素                           | `RPOP key`                             |
| `RPOPLPUSH` | 在一个原子时间内，执行两个动作：<br />（1）将列表 `source` 中最后一个元素弹出并返回给客户端<br />（2）将 `source` 弹出的元素插入到列表  `desination`，作为  `destination`   列表的头元素 | `RPOPLPUSH source destination`         |
| `RPUSH`     | （1）将一个或多个值 `value` 插入到列表 `key` 的表尾          | `RPUSH key value [value ...]`          |
| `RPUSHX`    | （1）将  `value` 插入到列表 `key` 的表尾，当且仅当 `key` 存在并且是一个列表<br />（2）`key` 不存在，`RPUSHX` 什么都不做 | `RPUSHX key value`                     |

另外 `List` 还有  `BLPOP`、`BRPOP`、`BRPOPLPUSH`三个命令没有说，它们是几个POP的阻塞版本，**即没有数据可以弹出的时候将阻塞客户端直到超时或者发现有可以弹出的元素为止**。

更多 `list` 命令命令参考这里 http://www.runoob.com/redis/redis-lists.html

### list 类型应用场景

- #### 队列-秒杀抢购 

`list` 类型的 `lpop` 和 `rpush`（或者反过来，`lpush` 和 `rpop`）能实现队列的功能，故而可以用  `Redis` 的 `list` 类型实现简单的点对点的消息队列。不过我不推荐在实战中这么使用，因为现在已经有 `Kafka`、`RabbitMQ`等成熟的消息队列了，它们的功能已经很完善了。

- #### 排行榜

`list` 类型的 `lrange` 命令可以分页查看队列中的数据。可将每隔一段时间计算一次的排行榜存储在 `list` 类型中，如京东每日的手机销量排行、学校每次月考学生的成绩排名、斗鱼年终盛典主播排名等，每日计算一次，存储在  `list` 类型中，接口访问时，通过  `page` 和 `size`  分页获取打擂金曲。

但是，并不是所有的排行榜都能用 `list`类型实现，只有定时计算的排行榜才适合使用 `list` 类型存储，与定时计算的排行榜相对应的是实时计算的排行榜，`list` 类型不能支持实时计算的排行榜，之后在介绍有序集合 `sorted set`  的应用场景时会详细介绍实时计算的排行榜的实现。

- #### 最新列表

`list`   类型的 `lpush` 命令和 `lrange` 命令能实现最新列表的功能，每次通过 `lpush` 命令往列表里插入新的元素，然后通过 `lrange` 命令读取最新的元素列表，如朋友圈的点赞列表、评论列表。

但是，并不是所有的最新列表都能用 `list` 类型实现，因为对于频繁更新的列表，`list`   类型的分页可能导致列表元素重复或漏掉，举个例子，当前列表里由表头到表尾依次有（E，D，C，B，A）五个元素，每页获取 3 个元素，用户第一次获取到（E，D，C）三个元素，然后表头新增了一个元素 F，列表变成了（F，E，D，C，B，A），此时用户取第二页拿到（C，B，A），元素C重复了。

只有不需要分页（比如每次都只取列表的前 5 个元素）或者更新频率低（比如每天凌晨更新一次）的列表才适合用 `list` 类型实现。对于需要分页并且会频繁更新的列表，需用使用有序集合 `sorted set` 类型实现。另外，需要通过时间范围查找的最新列表，`list` 类型也实现不了，也需要通过有序集合 `sorted set` 类型实现，如以成交时间范围作为条件来查询的订单列表。之后在介绍有序集合 `sorted set`   类型的应用场景时会详细介绍 `sorted set`  类型如何实现最新列表。

- #### 为何排行榜和列表不用  `sorted set` （主要出于对容量的考虑）

那么问题来了，对于排行榜和最新列表两种应用场景，`list` 类型能做到的 `sorted set` 类型都能做到，`list` 类型做不到的 `sorted set`  类型也能做到，那为什么还要使用 `list` 类型去实现排行榜或最新列表呢，直接用  `sorted set` 类型不是更好吗？

原因是  `sorted set` 类型占用的内存容量是  `list` 类型的数倍之多，可以参考  [数据类型实现原理](/classify/redis/redis五大数据类型实现原理)，对于列表数量不多的情况，可以用 `sorted set` 类型来实现，比如上文中举例的打擂金曲排行榜，每天全国只有一份，两种数据类型的内存容量差距可以忽略不计，但是如果要实现某首歌曲的翻唱作品地区排行榜，数百万的歌曲，`300` 多个地区，会产生数量庞大的榜单，或者数量更加庞大的朋友圈点赞列表，就需要慎重地考虑容量的问题了。

## hash数据类型

`Redis hash` 数据结构是一个键值对 `key-value` 集合，它是一个 `string` 类型的 `field` 和 `value` 的映射表，**`redis` 本身就是一个 `key-value` 型数据库，因此 `hash` 数据结构相当于在 `value` 中又套了一层 `key-value` 型数据**。所以 `redis` 中 `hash`  数据结构特别**适合存储关系型对象**。比如用来存储学生基本信息，或者用户信息等。

### 常用命令

| **命令**  | **描述**                                                     | **用法**                                  |
| --------- | ------------------------------------------------------------ | ----------------------------------------- |
| `HSET`    | （1）将哈希表 `Key` 中的域 `field` 的值设为 `value`<br />（2）`key` 不存在，一个新的  `Hash`  表被创建<br />（3）`field`  已经存在，旧的值被覆盖 | `HSET key field value`                    |
| `HGET`    | （1）返回哈希表 `key` 中给定域 `field`  的值                 | `HGET key field`                          |
| `HDEL`    | （1）删除哈希表 `key`  中的一个或多个指定域<br />（2）不存在的域将被忽略 | `HDEL key filed [field ...]`              |
| `HEXISTS` | （1）查看哈希表 `key` 中，给定域  `field` 是否存在，存在返回 `1` ，不存在返回 `0` | `HEXISTS key field`                       |
| `HGETALL` | （1）返回哈希表 `key` 中，所有的域和值                       | `HGETALL key`                             |
| `HINCRBY` | （1）为哈希表 `key` 中的域 `field` 加上增量 `increment`<br />（2）其余同 `INCR` 命令 | `HINCRYBY key filed increment`            |
| `HKEYS`   | （1）返回哈希表 `key` 中的所有域                             | `HKEYS key`                               |
| `HLEN`    | （1）返回哈希表 `key` 中域的数量                             | `HLEN key`                                |
| `HMGET`   | （1）返回哈希表 `key` 中，一个或多个给定域的值<br />（2）如果给定的域不存在于哈希表，那么返回一个 `nil` 值 | `HMGET key field [field ...]`             |
| `HMSET`   | （1）同时将多个 `field-value`  对设置到哈希表 `key` 中<br />（2）会覆盖哈希表中已存在的域<br />（3）`key` 不存在，那么一个空哈希表会被创建并执行 `HMSET` 操作 | `HMSET key field value [field value ...]` |
| `HVALS`   | （1）返回哈希表 `key` 中所有的域和值                         | `HVALS key`                               |

更多 `hash` 命令参考这里 https://www.runoob.com/redis/redis-hashes.html

### hash 数据类型应用场景

- #### 购物车 

购物车功能主要是通过用户点击商品添加到购物车，前端会传递商品 `id` 以及用于需要购买的数据到后端，`php` 通过前端传递的参数进而完成购物车的添加，增加或者减少购物车购买数量，删除或者清空购物车等功能。

如果说是使用 `redis` 来做我们可以以用户 `id` 为 `key`，商品 `id`  为 `field`，商品数量为 `value` ，恰好构成了购物车的 `3 `个要素。

- #### 存储对象 

`hash` 类型的（`key、field、value`）的结构与对象的 （对象  `id`、属性、值）的结构相似，也可以用来存储对象。

在介绍 `string` 类型的应用场景时有所介绍，`string + json` 也是存储对象的一种方式，那么存储对象时，到底用 `string + json`   还是用 `hash` 呢？

|        | string + json | hash     |
| ------ | ------------- | -------- |
| 效率   | 很高          | 高       |
| 容量   | 低            | 低       |
| 灵活性 | **低**        | 高       |
| 序列化 | 简单          | **复杂** |

当对象的某个属性需要频繁修改时，不适合用  `string+json`，因为它不够灵活，每次修改都需要重新将整个对象序列化并赋值，如果使用 `hash` 类型，则可以针对某个属性单独修改，没有序列化，也不需要修改整个对象。比如，商品的价格、销量、关注数、评价数等可能经常发生变化的属性，就适合存储在 `hash` 类型里。

当然，不常变化的属性存储在 `hash` 类型里也没有问题，比如商品名称、商品描述、上市日期等。但是，当对象的某个属性不是基本类型或字符串时，使用 `hash` 类型就必须手动进行复杂序列化，比如，商品的标签是一个标签对象的列表，商品可领取的优惠券是一个优惠券对象的列表等，即使以 `coupons`（优惠券）作为 `field`，`value` 想存储优惠券对象列表也还是要使用 `json` 来序列化，这样的话序列化工作就太繁琐了，不如直接用 `string + json` 的方式存储商品信息来的简单。

**综上，一般对象用 `string + json` 存储，对象中某些频繁变化的属性抽出来用 `hash` 存储。**

## set 数据类型

`redis` 集合 `set` 类型和 `list` 列表类型类似，都可以用来存储多个字符串元素的集合。**但是和 `list` 不同的是 `set` 集合当中不允许重复的元素**，而且 `set` 集合当中元素是没有顺序的，不存在元素下标。

`redis` 的 `set` 类型是使**用哈希表构造的**，因此复杂度是 `O(1)`，它支持集合内的增删改查，并且支持多个集合间的**交集、并集、差集**操作。可以利用这些集合操作，**解决程序开发过程当中很多数据集合间的问题**。

### 常用命令

| **命令**      | **描述**                                                     | **用法**                                |
| ------------- | ------------------------------------------------------------ | --------------------------------------- |
| `SADD`        | （1）将一个或多个  `member`  元素加入到 `key`  中，已存在在集合的 `member` 将被忽略<br />（2）假如 `key` 不存在，则只创建一个只包含 `member` 元素做成员的集合<br />（3）当 `key` 不是集合类型时，将返回一个错误 | `SADD key number [member ...]`          |
| `SCARD`       | （1）返回  `key` 对应的集合中的元素数量                      | `SCARD key`                             |
| `SDIFF`       | （1）返回一个集合的全部成员，该集合是第一个 `key` 对应集合和后面 `key` 对应集合的差集 | `SDIFF key [key ...]`                   |
| `SDIFFSTORE`  | （1）和 `SDIFF` 类似，但结果保存到 `destination`  集合而不是简单返回结果集<br />（2）`destination` 如果已存在，则覆盖 | `SDIFFSTORE destionation key [key ...]` |
| `SINTER`      | （1）返回一个集合的全部成员，该集合是所有给定集合的交集<br />（2）不存在的 `key` 被视为空集 | `SINTER key [key ...]`                  |
| `SINTERSTORE` | （1）和 `SINTER` 类似，但结果保存在   `destination` 集合而不是简单返回结果集<br />（2）如果 `destination`  已存在，则覆盖<br />（3）`destination`  可以是 `key`  本身 | `SINTERSTORE destination key [key ...]` |
| `SISMEMBER`   | （1）判断 `member` 元素是否 `key`  的成员，`0` 表示不是，`1` 表示是 | `SISMEMBER key member`                  |
| `SMEMBERS`    | （1）返回集合 `key` 中的所有成员<br />（2）不存在的 `key`  被视为空集 | `SMEMBERS key`                          |
| `SMOVE`       | （1）原子性地将 `member`  元素从  `source`  集合移动到 `destination` 集合<br />（2）`source` 集合中不包含 `member`元素，`SMOVE` 命令不执行任何操作，仅返回 `0`<br />（3）`destination` 中已包含 `member` 元素，`SMOVE` 命令只是简单做 `source` 集合的 `member`  元素移除 | `SMOVE source desination member`        |
| `SPOP`        | （1）移除并返回集合中的一个随机元素，如果 `count` 不指定那么随机返回一个随机元素<br />（2）`count`  为正数且小于集合元素数量，那么返回一个包含  `count`  个元素的数组且数组中的**元素各不相同**<br />（3）`count` 为正数且大于等于集合元素数量，那么返回整个集合<br />（4）`count` 为负数那么命令返回一个数组，数组中的**元素可能重复多次**，数量为 `count`  的绝对值 | `SPOP key [count]`                      |
| `SRANDMEMBER` | （1）如果 `count`   不指定，那么返回集合中的一个随机元素<br />（2）`count` 同上 | `SRANDMEMBER key [count]`               |
| `SREM`        | （1）移除集合 `key`  中的一个或多个 `member` 元素，不存在的 `member` 将被忽略 | `SREM key member [member ...]`          |
| `SUNION`      | （1）返回一个集合的全部成员，该集合是所有给定集合的并集<br />（2）不存在的 `key` 被视为空集 | `SUNION key [key ...]`                  |
| `SUNIONSTORE` | （1）类似 `SUNION`，但结果保存到 `destination`  集合而不是简单返回结果集<br />（2）`destination` 已存在，覆盖旧值<br />（3）`destination` 可以是 `key`本身 | `SUNION destination key [key ...]       |

### set数据类型应用场景

- #### 社交

利用集合的交并集特性，比如在社交领域，我们可以很方便的求出多个用户的共同好友，共同感兴趣的领域等。

- #### 抽奖 

`sRandMember`、`sPop` 这两个命令功能非常相似，都是从集合中返回一个元素值。**不同的是，`sRandMember` 不会从集合中删除返回的元素，但是 `sPop` 会删除。**

这两个命令可以分别实现不同的抽奖算法。 比如，集合中有 `100` 个元素，值从数字 `1` 到数字 `100`，我们定义抽到的是数字 `1` 的话，即表示中奖。 使用  `sRandMember` 的话，不管之前抽过多少次，下次抽中的概率都是 `1%`。而使用 `sPop` 的话，则每次抽中的概率都不一样。第一个人抽中概率是 `1%`，当第一个人没抽中的话，第二个人抽中概率就是 `1/99`，以此类推。

## zset 数据类型

`redis` 有序集合也是集合类型的一部分，所以它保留了集合中元素不能重复的特性，但是不同的是，有序集合给每个元素多设置了一个分数，利用该分数作为排序的依据。

有序集合可以利用分数进行从小到大的排序。虽然有序集合的成员是唯一的，但是分数`score`却可以重复。

就比如在一个班中，学生的学号是唯一的，但是每科成绩却是可以一样的，`redis` 可以利用有序集合存储学 生成绩快速做成绩排名功能。

### 常用命令

| **命令**           | **描述**                                                     | **用法**                                                    |
| ------------------ | ------------------------------------------------------------ | ----------------------------------------------------------- |
| `ZADD`             | （1）将一个或多个 `member` 元素及其 `score` 值加入有序集合 `key`  中<br />（2）如果   `member` 已经是有序集合的成员，那么更新 `member` 对应的 `score` 并重新插入 `member` 保证 `member` 在正确的位置上<br />（3）`score` 可以是整数值或双精度浮点数 | `ZADD key score member [[score member] [score member] ...]` |
| `ZCARD`            | （1）返回有序集合 `key` 的元素个数                           | `ZCARD key`                                                 |
| `ZCOUNT`           | （1） 返回有序集合 `key`中，`score` 值 `>=min` 且 `<=max`  的成员的数量 | `ZCOUNT key min max`                                        |
| `ZRANGE`           | （1）返回有序集合  `key` 中指定区间内的成员，成员位置按 `score` 从小到大排序<br />（2）具有相同 `score` 值的成员按字典序排列<br />（3）需要成员按 `score` 从大到小排列，使用 `ZREVRANGE`  命令<br />（4）下标参数 `start` 和 `stop` 都以0为底，也可以用负数，`-1` 表示最后一个成员，`-2` 表示倒数第二个成员<br />（5）可通过 `WITHSCORES` 选项让成员和它的 `score`  值一并返回 | `ZRANGE key start stop [WITHSCORES]`                        |
| `ZRANK`            | （1）返回有序集合 `key` 中成员 `member` 的排名，有序集合成员按`score` 值从小到大排列<br />（2）排名以 `0` 为底，即 `score` 最小的成员排名为0<br />（3）`ZREVRANK` 命令可将成员按 `score` 值从大到小排名 | `ZRANK key number`                                          |
| `ZREM`             | （1）移除有序集合  `key` 中的一个或多个成员，不存在的成员将被忽略<br />（2）当  `key` 存在但不是有序集合时，返回错误 | `ZREM key member [member ...]`                              |
| `ZREMRANGEBYRANK`  | （1）移除有序集合 `key` 中指定排名区间内的所有成员           | `ZREMRANGEBYRANK key start stop`                            |
| `ZREMRANGEBYSCORE` | （1）移除有序集合 `key` 中，所有  `score` 值 `>=min` 且  `<=max`  之间的成员 | `ZREMRANGEBYSCORE key min max`                              |

### zset数据类型应用场景

- #### 排行榜 

有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。

## geo 数据类型

**`GEO`**  功能在 `Redis3.2`  版本提供，支持存储地理位置信息用来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。

### 常用命令

| 命令                | 描述                                                         | 用法                                                         |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `geoadd`            | 添加地理位置的坐标，可以将一个或多个经度 `longitude`、纬度 `latitude`、位置名称  `member`添加到指定的 `key` 中 | `GEOADD key longitude latitude member [longitude latitude member ...]` |
| `geopos`            | 从给定的 `key` 里返回所有指定名称 `member` 的位置（经度和纬度），不存在的返回 `nil` | `GEOPOS key member [member ...]`                             |
| `geodist`           | 计算两个位置之间的距离                                       | `GEODIST key member1 member2 [m\|km\|ft\|mi]`                |
| `georadius`         | 根据用户给定的经纬度坐标来获取指定范围内的地理位置集合       | `GEORADIUS key longitude latitude radius m\|km\|ft\|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC\|DESC] [STORE key] [STOREDIST key]` |
| `georadiusbymember` | 根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合 | `GEORADIUSBYMEMBER key member radius m\|km\|ft\|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC\|DESC] [STORE key] [STOREDIST key]` |
| `geohash`           | 返回一个或多个位置对象的 `geohash` 值                        | `GEOHASH key member [member ...]`                            |
| `zrem`              | `GEO` 没有提供删除成员的命令，但是因为 `GEO` 的底层实现是  `zset`，所以可以借用 `zrem`命令实现对地理位置信息的删除 | `zrem key member`                                            |

单位参数说明：

1. `m` ：米（默认单位）
2. `km` ：千米
3. `mi` ：英里
4. `ft` ：英尺
5. `WITHDIST`: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回 
6. `WITHCOORD`: 将位置元素的经度和维度也一并返回
7. `WITHHASH`: 以 52 位有符号整数的形式， 返回位置元素经过原始 `geohash` 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大
8. `COUNT` 限定返回的记录数
9. `ASC:` 查找结果根据距离从近到远排序
10. `DESC`: 查找结果根据从远到近排序

## hyperloglog 数据类型

`Redis HyperLogLog` 是用来**做基数统计的算法**，`HyperLogLog` 的优点是，在输入元素的数量或者体积非常非常大时，**计算基数所需的空间总是固定的、并且是很小的。**

在 `Redis` 里面，每个 `HyperLogLog` 键只需要花费 **`12 KB`** 内存，就可以计算接近 `2^64` 个**不同元素的基数**。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。

但是，因为 `HyperLogLog` 只会根据输入元素来计算基数，**而不会储存输入元素本身**，所以 `HyperLogLog` 不能像集合那样，返回输入的各个元素。

比如数据集 {1， 3， 5， 7， 5， 7， 8}， 那么这个数据集的基数集为 {1， 3， 5 ，7， 8}， 基数（不重复元素）为5。 基数估计就是在误差可接受的范围内，快速计算基数。

### 常用命令

| 命令      | 描述                                          | 用法                                        |
| --------- | --------------------------------------------- | ------------------------------------------- |
| `pfadd`   | 添加指定元素到 `HyperLogLog` 中               | `PFADD key element [element ...]`           |
| `pfcount` | 返回给定 `HyperLogLog` 的基数估算值           | `PFCOUNT key [key ...]`                     |
| `pfmerge` | 将多个 `HyperLogLog` 合并为一个 `HyperLogLog` | `PFMERGE destkey sourcekey [sourcekey ...]` |

注意，它使用的是概率算法，通过存储元素的 `hash` 值的第一个 `1`  的位置，来计算元素数量，这样做存在误差，不适合绝对准确计数的场景。`redis`  中实现的 `HyperLogLog`，只需要 `12K` 内存，在标准误差 `0.81%` 的前提下，能够统计 `2^64` 个数据。

### hyperloglog数据类型应用场景和对比

- ##### 统计 `uv`
  - 对比 `string`

    其实要是单纯的统计 `pv` 是比较好办的，直接用 `redis` 的 `incr`  就行，但是 `uv`  的话，它要去重，同一个用户一天之内的多次访问请求只能计数一次。这就要求每一个网页请求都需要带上用户的 `ID`，无论是登陆用户还是未登陆用户都需要一个唯一 `ID `来标识。

  - 对比 `set`

    比较容易想到的是为每一个页面一个独立的 `set` 集合来存储所有当天访问过此页面的用户 `ID`。当一个请求过来时，我们使用 `sadd` 将用户 `ID` 塞进去就可以了。通过 `scard` 可以取出这个集合的大小，这个数字就是这个页面的 `UV` 数据。没错，这是一个非常简单的方案。

    但是，如果你的页面访问量非常大，比如一个爆款页面几千万的 `UV`，你需要一个很大的 `set `集合来统计，这就非常浪费空间。如果这样的页面很多，那所需要的存储空间是惊人的。

  - 对比 `hash`

    `hash` 和 `set`  在处理 `uv` 的问题上其实类似，把用户 `id`  作为  `hash`  的 `key`  的确可以去重，但是如果访问量大了之后也会消耗很大的内存空间 `hash` 和  `set` 在处理 `uv` 的问题上其实类似，把用户 `id`  作为 `hash`   的 `key` 的确可以去重，但是如果访问量大了之后也会消耗很大的内存空间

  - 对比 `bitmap`

    `bitmap`  同样是一种可以统计基数的方法，可以理解为用 `bit` 数组存储元素，例如 `01101001`，表示的是  [1，2，4，8]，`bitmap` 中  `1` 的个数就是基数。`bitmap` 也可以轻松合并多个集合，只需要将多个数组进行异或操作就可以了。` bitmap` 相比于`set`，`hash` 也大大节省了内存，我们来粗略计算一下，统计  1 亿个数据的基数，需要的内存是：`100000000/8/1024/1024 ≈ 12M`。

  - 使用 `HyperLogLog`

    虽然 `bitmap`  在节省空间方面已经有了不错的表现，但是如果需要统计 `100000000` 个对象，就需要大约 `12G` 的内存，显然这个结果仍然不能令我们满意。在这种情况下，`HyperLogLog` 将会出来拯救我们。

    使用 `pfadd` 和 `pfcount` 来实现，`pfadd` 用法和 `set` 集合的 `sadd` 是一样的，来一个用户 `ID`，就将用户 `ID` 塞进去就是。`pfcount` 和 `scard` 用法是一样的，直接获取计数值。关键是它非常省空间，载统计海量 `uv` 的时候，只占用了 `12k` 的空间

## bitmap 数据类型

`Redis从2.2.0`  版本开始新增了 `setbit`，`getbit`，`bitcount` 等几个 `bitmap` 相关命令。虽然是新命令，但是并没有新增新的数据类型，因为 `setbit` 等命令只不过是在 `set` 上的扩展。这里把它当作一种数据类型来写。

**在一台 `2010MacBook Pro` 上，`offset` 为 `2^32-1`​（分配 `512MB`）需要～`300ms`，`offset` 为 `2^30-1` ​(分配`128MB`)需要～`80ms`，`offset` 为 `2^28-1`​（分配 `32MB`）需要～`30ms`，`offset` 为 `2^26-1`​​（分配 `8MB`）需要 `8ms`。<来自官方文档>**

通过一个 `bit` 位来表示某个元素对应的值或者状态，其中的 `key` 就是对应元素本身。我们知道 `8` 个 `bit` 可以组成一个 `Byte`，所以`bitmap` 本身会极大的节省储存空间。同 `string` 类型，`bitmap` 最大存储 `512M`，即约 `43` 亿的位，不过建议每个键值的位数都控制下，因为读取时候时间复杂度 `O(n)`，越大的串读的时间花销越多。

```
512 M = 512*1024 KB = 524288 KB = 524288*1024 B = 536870912*8 bit = 4294967296 bit
```

优点：

1. 基于最小的单位 `bit` 进行存储，所以非常省空间。
2. 设置时候时间复杂度 `O(1)` 、读取时候时间复杂度 `O(n)`，操作是非常快的。
3. 二进制数据的存储，进行相关计算的时候非常快。
4. 方便扩容

### 常用命令

| 命令       | 描述                                                         | 用法                                |
| ---------- | ------------------------------------------------------------ | ----------------------------------- |
| `getbit`   | 对 `key` 所存储的字符串值，获取指定偏移量上的位 `bit`        | `getbit key offset`                 |
| `setbit`   | 对 `key` 所存储的字符串值，设置或清除指定偏移量上的位`bit`<br />（1）返回值为该位在 `setbit` 之前的值<br/>（2）`value` 只能取 `0` 或  `1`<br/>（3）`offset` 从 `0` 开始，即使原位图只能 `10` 位，`offset` 可以取 `1000` | `setbit key offset value`           |
| `bitcount` | 获取位图指定范围中位值为 `1` 的个数，如果不指定 `start` 与 `end` ，则取所有 | `bitcount key [start end]`          |
| `bitop`    | 做多个`BitMap` 的 `and`（交集）、`or`（并集）、`not`（非）、`xor`（异或）操作并将结果保存在 `destKey` 中 | `bitop op destKey key1 [key2...]`   |
| `bitpos`   | 计算位图指定范围第一个偏移量对应的的值等于 `targetBit` 的位置<br />（1）找不到返回 `-1`<br />（2）`start` 与 `end` 没有设置，则取全部<br />（3）`targetBit` 只能取 `0` 或者 `1` | `bitpos key tartgetBit [start end]` |

### setbit数据类型应用场景

- #### 用户在线状态

使用`bitmap` 是一个节约空间效率又高的一种方法，只需要一个 `key`，然后用户 `id` 为偏移量 `offset`，如果在线就设置为 `1` ，不在线就设置为 `0`，`3` 亿用户只需要 `36MB` 的空间。

```
$status = 1;
$redis->setBit('online',$uid,$status);
$redis->getBit('online',$uid);
```

- #### 统计用户活跃情况

使用时间作为缓存的 `key`，然后用户 `id` 为 `offset`，如果当日活跃过就设置为 `1`。之后通过 `bitOp` 进行二进制计算算出在某段时间内用户的活跃情况。

```
$status = 1;
$redis->setBit('active_20170708', $uid, $status);
$redis->setBit('active_20170709', $uid, $status);

$redis->bitOp('AND', 'active', 'active_20170708', 'active_2017070'); 
```

- #### 用户签到

使用 `redis` 的 `bitmap`，由于是长尾的记录，所以 `key` 主要由 `uid`  组成，设定一个初始时间，往后每加一天即对应 `value` 中的 `offset` 的位置。

```
$start_date = '20170708';
$end_date = '20170709';
$offset = floor((strtotime($start_date) - strtotime($end_date)) / 86400);
$redis->setBit('sign_123456', $offset, 1);
//算活跃天数
$redis->bitCount('sign_123456', 0, -1)
```

无需分片，一年 `365` 天，`3` 亿用户约占 `300000000*365/8/1000/1000/1000=13.68g`。存储成本是不是很低。

- #### 布隆过滤器

解决缓存穿透的方法之一就是设置布隆过滤器，而布隆过滤器的原理就是一个 `hashtable`，对键值进行多个 `hash_fun`，然后根据得出的值，在对应的位置上的设置值为 `1`。实际上也可以用 `bitmap` 来记录位置的值。



### **使用bitmap过程中可能会遇到的坑**

`bitcout` 的陷阱：

如果你有仔细看前文的用法，会发现有这么一个备注“返回一个指定 `key` 中位的值为 `1` 的个数(是以 `byte` 为单位不是 `bit`)”，这就是坑的所在。

有图有真相：

![这里写图片描述](/redis/redis-bitcount的陷阱.png)

所以 `bitcount 0 0` 那么就应该是第一个字节中1的数量的，注意是字节，第一个字节也就是 1，2，3，4，5，6，7，8 这八个位置上。 